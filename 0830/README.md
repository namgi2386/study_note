# 🚓시작하기 2

## 🚕목차🚕
>어제 내용 이어서 진행

[5. 비트연산](#비트연산)  
[6. 실수](#실수)

---
---

## 🚗비트연산🚗
+ 1bit
+ 1Byte = 8bit
> `1111000011110000` `==` `16bit=2byte`

`4 & 3 == 0b100 & 0b011 == 0b000 == 0`  
`4 | 3 == 0b100 | 0b011 == 0b111 == 7`  
`0xa == 10`  `0xfa = 16*15+10`  

#### 🚚진수변경
+ 2진수로 변경 : `bin(10)`
+ 16진수로 변경 : `hex(10)`
+ 2진수를 10진수로 : `int('1011',2)`
+ 16진수를 10진수로 : `int('b',16)`  

#### 🚚AND OR 연산
+ `0x4A3 | 25(10)` 계산과정
+ `0100 1010 0011 | 0001 1001` 
+ `==` `0100 1011 1011` 
+ `==` `10010111011` `==` `1211(10)`

#### 🚚XOR
+ 같으면 0 다르면 1
+ 7070 ^ 1004(KEY) = 6258 (인코딩)
+ 6258 ^ 1004(KEY) = 7070 (디코딩)

#### 🚚shift
+ `13 << 2`
+ `==` `0b1101 << 3`
+ `==` `0b1101000`
+ `==` `13*(2**3)`
+ `==` `104`

#### 🚚 NOT 
`~` 모든 비트 반전시킴  
`~0010` `==` `1101`

#### 🚚응용 (부분집합 만들기)
```
arr = [1,2,3,4]

for i in range(1<<len(arr)):
    for idx in range(len(arr)):
        if i & (1<<idx): 
# i번쨰 부분집합에 idx 요소가 포함되었는지 확인하기
            print(arr[idx], end=" ")
    print()

#모든 부분집합 출력하기
```
#### 🚚응용 (음수표현)
`2의 보수`를 사용하여 음수 표현 

+ `0010`의 2의보수는 반전후 +1
+ 즉 `1101 + 1` `==` `1110`
+ `0010` `== 2`
+ `1110` `== -2`
+ 두개 더하면
+ `10000` `== 0` (4자리넘어서는비트는 버림)

(참고)
+ `1110` 중 맨 앞의 `1`이 sign bit `MSB`
+ `MSB` 0일때 양수 1일때 음수
+ `1110` `==` ` -8 +4 +2 +0` `==` `-2` 


## 🚙실수🚙🚙🚙🚙🚙🚙🚙🚙💭

#### 🚛소수점 출력법
+ 소수점 2자리까지 출력 : `f'{num:.2f}'`
+ 실수는 최대 1.8 * 10^308
+ 최소 5.0*10^-324
+ `0.75` `==` `2^(-1)` `+` `2^(-2)` `==` `0.11(2)`
+ 0.1+0.1+0.1 != 0.3

#### 🚛 부동소수점 표기법(IEEE)
+ 실수저장형식 
+ 32bit 사용
  + 부호 1비트
  + 지수 8비트 ( 지수부= 지수+bias127)
  + 가수는 23비트

#### 🚛 실습 (비트마스킹)
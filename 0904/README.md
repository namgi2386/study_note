# 🦙분할 정복

## 🐫목차
[1. 분할정복](#분할-정복)

[2. 병합 정렬](#병합-정렬)

[3. 퀵 정렬](#퀵-정렬)

[4. 이진 검색](#이진-검색)

## 🐪분할정복 `divide and conquer`
#### 🦨 Top-down approach
+ 큰문제를 작은문제로 나눠서 풀어내자
#### 🦨 `C^n` 거듭제곱 
+ 2^13 을 분할정복 할 예정
+ 원래 2를 13번 곱함은 O(n)
+ 분할하면 2^6*2^6 > 2^3*2^3... > 2*2*2...
+ 분할하면 3개단계로 끝남 O(logn)

## 🐐병합 정렬
#### 🦡 `O(nlogn)`
+ 나눌 수 없을때까지 분할하기 : `logn`
+ 각 단계 정렬하면서 합치기
+ [10,69] [2,30]을 합칠때
  + 10,2 비교 2정렬
  + 10,30 비교 10정렬
  + 69 30 비교 30정렬
  + 마지막 69정렬

<div style=" border: solid mediumslateblue; padding: 1rem">
<details>
<summary>
병합정렬 강사님코드
</summary>

```py
첨부 전 (b_병합정렬.py 참고)
```

</details>
</div>

## 🐑퀵 정렬
#### 🐀 pivot 피봇 
+ 피봇은 맨왼쪽요소
+ 간단하니까
+ but 역순정렬일때 최악의 swap 발생 `O(n^2)`
+ 그래서 다른방법으로 피봇설정 필요
#### 🐀 Hoare-partition
1. `idx_0` : 피봇
2. `idx_1` : i 증가하며 피봇보다 큰값 찾기
3. `idx_(n-1)` : j 감소하며 피봇보다 작은값 찾기
4. i와 j가 모두 찾았다면 swap
5. i와 j가 교차했을때
6. j의 위치와 피봇위치 값들 swap
#### 🐀 Lomuto partition (느림)
1. `idx_(n-1)` : 피봇
2. `idx_(-1)` : i
3. `idx_(0)` : j
4. i,j함께 움직임
5. 피봇보다 작으면 그대로 함께 이동
6. 큰수발견시 j만 이동
7. 계속 큰수면 계속 j만 이동 
8. 작은수발견시 i+1위치에 있던 큰수와 j의 값을 변경
9. 반복
#### 🐀 퀵정렬 시간 복잡도
+ 평균적으로 매우 빠르기에, 대용량data에서 사용
+ 평균 `O(nlogn)`
+ 파티셔닝 `n` 
+ 분할작업 `logn` 
+ 최악 역순정렬데이터 `O(n^2)`

![alt text](image-1.png)

## 🐏이진 검색
🐁 
+ 최악경우 = sort정렬 nlogn + 탐색 logn

## 오늘 할일
+ 실습과제
+ 양팔저울 > 강사님 질문
+ 지렁이 > 강사님 질문 후 풀이
+ 물놀이 풀이
## 내일 할일
+ 나머지 a형문제풀이
+ 모의 문제 풀이